<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Generator 函数</title>
<script type="text/javascript">
//1简介
//a)基本概念
//Generator函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；
//二是，函数体内部使用yield语句，定义不同的内部状态（yield语句在英语里的意思就是“产出”）
function* helloWorldGenerator(){
	yield 'hello';
	yield 'world';
	return 'ending';
}
var hw = helloWorldGenerator();
//调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，
//也就是上一章介绍的遍历器对象（Iterator Object）
//Generator函数时分段执行的,yield语句是暂停执行的标记,而next方法可以恢复执行
hw.next()
// { value: 'hello', done: false }
hw.next()
// { value: 'world', done: false }
hw.next()
// { value: 'ending', done: true }
hw.next()
// { value: undefined, done: true }
//b)yield语句
function* gen(){
	yield 123 + 456;
}
console.log(gen().next());
//上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值
//yield语句与return语句既有相似之处,也有区别。相似之处在于,都能返回紧跟在语句后面的那个表达式的值
//区别在于每次遇到yield,函数暂停执行,下一次再从该位置继续向后执行,而return语句不具备位置记忆的功能
//一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield语句
//正常函数只能返回一个值，因为只能执行一次return；Generator函数可以返回一系列的值，因为可以有任意多个yield

//Generator函数可以不用yield语句，这时就变成了一个单纯的暂缓执行函数。
function* f(){
	console.log("执行了");
}
var generator = f();
setTimeout(function(){
	generator.next();
},2000);
//上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个Generator函数，
//就变成只有调用next方法时，函数f才会执行
//另外需要注意，yield语句不能用在普通函数中，否则会报错
(function(){
	yield 1;
})();
//// SyntaxError: Unexpected number
//上面代码在一个普通函数中使用yield语句，结果产生一个句法错误
var arr = [1,[[2,3],4],[5,6]];
var flat = function* (a){
	a.forEach(function(item){
		if(typeof item !== 'number'){
			yield* flat(item);
		}else{
			yield item;
		}
	});
};
//上面代码也会产生句法错误，因为forEach方法的参数是一个普通函数，但是在里面使用了yield语句
for(var f of flat(arr)){
	console.log(f);
}
//一种修改方法是改用for循环
var arr = [1,[[2,3],4],[5,6]];
var flat = function* (a){
	var length = a.length;
	for(var i=0; i < length; i++){
		var item = a[i];
		if(typeof item !== 'number'){
			yield* flat(item);
		}else{
			yield item;
		}
	}
};

for(var f of flat(arr)){
	console.log(f);
}
//// 1, 2, 3, 4, 5, 6

//// 另外，yield语句如果用在一个表达式之中，必须放在圆括号里面
console.log("Hello" + yield);//error
console.log("Hello" + yield 123);//error
console.log('hello' + (yield));//ok
console.log("hello" + (yield 123));//ok
//yield语句用作函数参数或赋值表达式的右边，可以不加括号。
//foo(yield 'a',yield ''b');
//let input = yield;

//c)与Iterator接口的关系
//由于Generator函数就是遍历器生成函数，因此可以把Generator赋值给对象的Symbol.iterator属性，
//从而使得该对象具有Iterator接口
var myIterable = {};
myIterable[Symbol.iterator]=function*(){
	yield 1;
	yield 2;
	yield 3;
};
console.log([...myIterable]);//[1,2,3]
//Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身
function* gen(){
	//...
}
var g = gen();
console.log(g[Symbol.iterator]() === g);//true

//2next方法的参数
//next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。
function* f(){
	for(var i=0; true; i++){
		var reset = yield i;
		if(reset){
			i = -1;
		}
	}
}
var g = f();
g.next() // { value: 0, done: false }
g.next() // { value: 1, done: false }
g.next(true) // { value: 0, done: false }
//可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为
//再看一个例子
function* foo(x){
	var y = 2 * (yield (x + 1));
	var z = yield(y / 3);
	return (x + y + z);
}

a.next() // Object{value:6, done:false}
a.next() // Object{value:NaN, done:false}
a.next() // Object{value:NaN, done:true}

var b = foo(5);
b.next() // { value:6, done:false }
b.next(12) // { value:8, done:false }
b.next(13) // { value:42, done:true }
//注意，由于next方法的参数表示上一个yield语句的返回值，所以第一次使用next方法时，不能带有参数。
//V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的
//从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数
//如果想要第一次调用next方法时，就能够输入值，可以在Generator函数外面再包一层
function wrapper(generatorFunction){
	return function(...args){
		let generatorObject = generatorFunction(...args);
		generatorObject.next();
		return generatorObject;
	};
}
const wrapped = wrapper(function* (){
	console.log(`First input ${yield}`);
	return 'DONE';
});
wrapped().next('hello!');
// First input: hello!
//再看一个通过next方法的参数，向Generator函数内部输入值的例子。
function* dataConsumer(){
	console.log('started');
	console.log(`1,${yield}`);
	console.log(`2,${yield}`);
	return 'result';
}
let genObj = dataConsumer();
console.log(genObj.next());
console.log(genObj.next('a'));
console.log(genObj.next('b'));

//3for...of循环
//for...of循环可以自动遍历Generator函数时生成的Iterator对象，且此时不再需要调用next方法
function *foo(){
	yield 1;
	yield 2;
	yield 3;
	yield 4;
	yield 5;
	return 6;
}
for(let v of foo()){
	console.log(v);//1,2,3,4,5
}
//下面是一个利用Generator函数和for...of循环，实现斐波那契数列的例子。
function* fibonacci(){
	let [prev,curr] = [0,1];
	for(;;){
		[prev,curr] = [curr,prev + curr];
		yield curr;
	}
}
for(let n of fibonacci()){
	if(n > 1000) break;
	console.log(n);
}
//从上面代码可见，使用for...of语句时不需要使用next方法
//利用for...of循环，可以写出遍历任意对象（object）的方法。原生的JavaScript对象没有遍历接口，无法使用for...of循环，
//通过Generator函数为它加上这个接口，就可以用了
function* objectEntries(obj){
	let propKeys = Reflect.ownKeys(obj);
	for(let propKey of propKeys){
		yield [propKey,obj[propKey]];
	}
}
let jane = {first:'Jane',last:'Doe'};
for(let [key,value] of objectEntries(jane)){
	console.log(`${key},${value}`);
}
//加上遍历器接口的另一种写法是，将Generator函数加到对象的Symbol.iterator属性上面
function* objectEntries() {
  let propKeys = Object.keys(this);

  for (let propKey of propKeys) {
    yield [propKey, this[propKey]];
  }
}
let jane = { first: 'Jane', last: 'Doe' };
jane[Symbol.iterator] = objectEntries;
for (let [key, value] of jane) {
	  console.log(`${key}: ${value}`);
}
//除了for...of循环以外，扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，
//它们都可以将Generator函数返回的Iterator对象，作为参数
function* numbers(){
	yield 1;
	yield 2;
	return 3;
	yield 4;
}
//扩展运算符
console.log([...numbers()]);
//Array.from方法
console.log(Array.from(numbers()));
//解构赋值
let [x,y] = numbers();
console.log(x,y);
//for...of循环
for(let n of numbers()){
	console.log(n);
}

//4Generator.prototype.throw()
//Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获
var g = function* (){
	try{
		yield;
	}catch(e){
		console.log("内部捕获",e);
	}
};
var i = g();
i.next();
try{
	i.throw("a");
	i.throw("b");
}catch(e){
	console.log("外部捕获",e);
}
//内部捕获 a
//外部捕获 b
//throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例
var g = function* (){
	try{
		yield;
	}catch(e){
		console.log(e);
	}
};
var i = g();
i.next();
i.throw(new Error("出错了"));
//// Error: 出错了！(…)
//意，不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，是用遍历器对象的throw方法抛出的，
//而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获
var g = function* (){
	while(true){
		try{
			yield;
		}catch(e){
			if(e!='a'){
				throw e;
			}
			console.log('内部捕获',e);
		}
	}
};
var i = g();
i.next();
try{
	throw new Error('a');
	throw new Error("b");
}catch(e){
	console.log("外部捕获",e);
}
// 外部捕获 [Error: a]
//如果Generator函数内部没有部署try...catch代码块，那么throw方法抛出的错误，将被外部try...catch代码块捕获
var g = function*(){
	while(true){
		yield;
		console.log("内部捕获",e);
	}
};
var i = g();
i.next();
try{
	i.throw('a');
	i.throw('b');
}catch(e){
	console.log("外部捕获",e);
}
//// 外部捕获 a
//上面代码中，Generator函数g内部没有部署try...catch代码块，所以抛出的错误直接被外部catch代码块捕获
//如果Generator函数内部和外部，都没有部署try...catch代码块，那么程序将报错，直接中断执行
var gen = function*(){
	yield console.log('hello');
	yield console.log("world");
};
var g = gen();
g.next();
g.throw();
//hello
//Uncaught undefined
//上面代码中，g.throw抛出错误以后，没有任何try...catch代码块可以捕获这个错误，导致程序报错，中断执行
//throw方法被捕获以后，会附带执行下一条yield语句。也就是说，会附带执行一次next方法
var gen = function* gen(){
	try{
		yield console.log('a');
	}catch(e){
		//...
	}
	yield console.log('b');
	yield console.log('c');
};
var g = gen();
g.next() // a
g.throw() // b
g.next() // c
//上面代码中，g.throw方法被捕获以后，自动执行了一次next方法，所以会打印b。另外，也可以看到，
//只要Generator函数内部部署了try...catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历
//另外，throw命令与g.throw方法是无关的，两者互不影响
var gen = function*(){
	yield console.log('a');
	yield console.log('b');
};
var g = gen();
g.next();
try{
	throw new Error();
}catch(e){
	g.next();
}
//a
//b

//Generator函数体外抛出的错误，可以在函数体内捕获；反过来，Generator函数体内抛出的错误，也可以被函数体外的catch捕获
function *foo(){
	var x = yield 3;
	var y = x.toUpperCase();
	yield y;
}
var it = foo();
it.next();
try{
	it.next(42);
}catch(err){
	console.log(err);
}
//上面代码中，第二个next方法向函数体内传入一个参数42，数值是没有toUpperCase方法的，所以会抛出一个TypeError错误，被函数体外的catch捕获

//一旦Generator执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，
//即JavaScript引擎认为这个Generator已经运行结束了
function* g(){
	yield 1;
	console.log('throwing an exception');
	throw new Error('generator broke!');
	yield 2;
	yield 3;
}

function log(generator){
	var v;
	console.log('starting generator');
	try{
		v = generator.next();
		console.log('第一次运行next方法',v);
	}catch(err){
		console.log("扑捉错误",v);
	}
	try{
		v = generator.next();
		console.log('第二次运行next方法',v);
	}catch(err){
		console.log("扑捉错误",v);
	}
	try{
		v = generator.next();
		console.log('第三次运行next方法',v);
	}catch(err){
		console.log("扑捉错误",v);
	}
	console.log("caller done");
}

log(g());

//5Generator.prototype.return()
//6yield*语句
//7作为对象属性的Generator函数
//8Generator函数的this
//9含义
//10应用

</script>
</head>
<body>
</body>
</html>
